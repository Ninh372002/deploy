{"ast":null,"code":"import panzoom from 'panzoom';\nexport default {\n  name: \"ImageRes\",\n  data() {\n    return {\n      scale: 1,\n      // Initial scale factor\n      canvasWidth: 500,\n      // Default canvas width\n      canvasHeight: 500,\n      // Default canvas height\n      minWidth: 400,\n      maxWidth: 500,\n      pointClicked: [],\n      prevPoint: -1,\n      curPoint: -1,\n      scaleX: 1,\n      scaleY: 1,\n      labelAll: false,\n      distanceMap: false\n    };\n  },\n  watch: {\n    source() {\n      this.drawImageOnCanvas();\n    }\n  },\n  mounted() {\n    // Initialize Panzoom when the component is mounted\n    this.initPanzoom();\n\n    // init image to canvas object\n    this.calculateCanvasSize();\n    this.drawImageOnCanvas();\n  },\n  props: {\n    title: {\n      type: String,\n      default: ''\n    },\n    alt: {\n      type: String,\n      default: ''\n    },\n    source: {},\n    coordArray: {\n      type: Array,\n      // eslint-disable-next-line vue/require-valid-default-prop\n      default: []\n    },\n    points: {\n      type: Array,\n      // eslint-disable-next-line vue/require-valid-default-prop\n      default: []\n    },\n    strokeLine: {\n      type: String,\n      default: '#000000'\n    }\n  },\n  methods: {\n    drawBoundary(context, coord) {\n      context.beginPath();\n      context.strokeStyle = this.strokeLine;\n      context.lineWidth = 2;\n      context.moveTo(coord[1][0] * this.scaleX, coord[0][0] * this.scaleY);\n      for (let i = 1; i < coord[0].length; i++) {\n        context.lineTo(coord[1][i] * this.scaleX, coord[0][i] * this.scaleY);\n      }\n      context.closePath();\n      context.stroke();\n    },\n    drawDistaceMap(context, points, coord) {\n      context.lineWidth = 0.5;\n      context.strokeStyle = \"black\";\n      for (let i = 0; i < points.length; i++) {\n        // draw the boundary points\n        for (let j = 0; j < coord[0][0].length; j++) {\n          context.beginPath();\n          context.moveTo(points[i][1] * this.scaleX, points[i][0] * this.scaleY);\n          context.lineTo(coord[i][1][j] * this.scaleX, coord[i][0][j] * this.scaleY);\n          context.stroke();\n        }\n        context.strokeStyle = 'black';\n        context.lineWidth = 0.5;\n        context.stroke();\n      }\n    },\n    handleShowDistanceMap() {\n      const canvas = this.$refs.canvas;\n      const context = canvas.getContext(\"2d\");\n      if (this.distanceMap == false) {\n        this.drawDistaceMap(context, this.points, this.coordArray);\n      } else {\n        this.drawImageOnCanvas();\n      }\n    },\n    handleAllPoints() {\n      const canvas = this.$refs.canvas;\n      const context = canvas.getContext(\"2d\");\n      if (this.labelAll == false) {\n        for (let i = 0; i < this.coordArray.length; i++) {\n          this.drawBoundary(context, this.coordArray[i]);\n          this.pointClicked[i] = 1;\n        }\n      } else {\n        this.drawImageOnCanvas();\n        this.pointClicked = [];\n      }\n    },\n    handleClickPoint(index) {\n      if (this.pointClicked[index]) {\n        return;\n      }\n      if (this.curPoint != -1) {\n        this.prevPoint = this.curPoint;\n      }\n      this.pointClicked = [];\n      this.pointClicked[index] = 1;\n      this.curPoint = index;\n      const canvas = this.$refs.canvas;\n      const context = canvas.getContext(\"2d\");\n      const image = new Image();\n      image.src = this.source;\n      // Clear the pre boundary\n      if (this.prevPoint != -1) {\n        context.drawImage(image, 0, 0, this.canvasWidth, this.canvasHeight);\n      }\n      // Draw new boundary\n      this.drawBoundary(context, this.coordArray[this.curPoint]);\n    },\n    calculateCanvasSize() {\n      const image = new Image();\n      image.src = this.source;\n\n      // Calculate the canvas dimensions based on the image's aspect ratio\n      image.onload = () => {\n        const aspectRatio = image.width / image.height;\n\n        // Set canvas width within the specified range\n        this.canvasWidth = Math.min(Math.max(image.width, this.minWidth), this.maxWidth);\n\n        // Calculate and set canvas height to maintain the image's aspect ratio\n        this.canvasHeight = Math.round(this.canvasWidth / aspectRatio);\n        this.scaleX = this.canvasWidth / image.width;\n        this.scaleY = this.canvasHeight / image.height;\n      };\n    },\n    drawImageOnCanvas() {\n      return new Promise(() => {\n        const canvas = this.$refs.canvas;\n        const context = canvas.getContext('2d');\n        const image = new Image();\n        image.onload = () => {\n          context.drawImage(image, 0, 0, this.canvasWidth, this.canvasHeight);\n          // You can add additional drawing logic here if needed\n        };\n        image.src = this.source;\n      });\n    },\n    initPanzoom() {\n      // Get the panzoom container and target elements using refs\n      const container = this.$refs.panzoomElement;\n      const target = this.$refs.canvas;\n\n      // Initialize Panzoom\n      const pz = panzoom(target, {\n        // You can customize options here\n        maxZoom: 10,\n        minZoom: 1\n      });\n\n      // Optional: Add event listeners for additional functionality\n      container.addEventListener('wheel', pz.zoomWithWheel);\n    }\n  }\n};","map":{"version":3,"names":["panzoom","name","data","scale","canvasWidth","canvasHeight","minWidth","maxWidth","pointClicked","prevPoint","curPoint","scaleX","scaleY","labelAll","distanceMap","watch","source","drawImageOnCanvas","mounted","initPanzoom","calculateCanvasSize","props","title","type","String","default","alt","coordArray","Array","points","strokeLine","methods","drawBoundary","context","coord","beginPath","strokeStyle","lineWidth","moveTo","i","length","lineTo","closePath","stroke","drawDistaceMap","j","handleShowDistanceMap","canvas","$refs","getContext","handleAllPoints","handleClickPoint","index","image","Image","src","drawImage","onload","aspectRatio","width","height","Math","min","max","round","Promise","container","panzoomElement","target","pz","maxZoom","minZoom","addEventListener","zoomWithWheel"],"sources":["C:\\Users\\Ninh\\Desktop\\Doan\\DATN-NTT2024\\src\\components\\ImageRes.vue"],"sourcesContent":["<template>\r\n  <div class=\"result\">\r\n    <div class=\"image-box\">\r\n      <div class=\"text-white text-lg\">\r\n        <span>{{ title }}</span>\r\n      </div>\r\n      <div class=\"image\">\r\n        <div ref=\"panzoomElement\">\r\n          <canvas ref=\"canvas\" :width=\"canvasWidth\" :height=\"canvasHeight\"></canvas>\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <div class=\"roi-manager\">\r\n      <div class=\"text-center text-lg border-b-2 border-green-400\">\r\n        Points\r\n      </div>\r\n      <div class=\"roi-points\">\r\n        <div v-for=\"(item, index) in this.points\" :key=\"index\" class=\"point\"\r\n             :class=\"this.pointClicked[index] && 'bg-green'\"\r\n             @click=\"handleClickPoint(index)\">\r\n          <span>{{ item[0] }}</span> - <span>{{ item[1] }}</span>\r\n        </div>\r\n      </div>\r\n      <div class=\"roi-extension\">\r\n        <div class=\"text-lg\">\r\n          <div class=\"flex\">\r\n            <span class=\"basis-28\">Select All</span>\r\n            <input type=\"checkbox\" v-model=\"labelAll\" :disabled=\"distanceMap\" @click=\"handleAllPoints\">\r\n          </div>\r\n          <div class=\"flex\">\r\n            <span class=\"basis-28\">Distance Map</span>\r\n            <input type=\"checkbox\" v-model=\"distanceMap\" :disabled=\"labelAll\" @click=\"handleShowDistanceMap\">\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport panzoom from 'panzoom';\r\n\r\nexport default {\r\n  name: \"ImageRes\",\r\n  data() {\r\n    return {\r\n      scale: 1, // Initial scale factor\r\n      canvasWidth: 500, // Default canvas width\r\n      canvasHeight: 500, // Default canvas height\r\n      minWidth: 400,\r\n      maxWidth: 500,\r\n      pointClicked: [],\r\n      prevPoint: -1,\r\n      curPoint: -1,\r\n      scaleX: 1,\r\n      scaleY: 1,\r\n      labelAll: false,\r\n      distanceMap: false\r\n    };\r\n  },\r\n  watch: {\r\n    source() {\r\n      this.drawImageOnCanvas();\r\n    }\r\n  },\r\n  mounted() {\r\n    // Initialize Panzoom when the component is mounted\r\n    this.initPanzoom();\r\n\r\n    // init image to canvas object\r\n    this.calculateCanvasSize();\r\n    this.drawImageOnCanvas();\r\n  },\r\n  props: {\r\n    title: {\r\n      type: String,\r\n      default: '',\r\n    },\r\n    alt: {\r\n      type: String,\r\n      default: '',\r\n    },\r\n    source: {},\r\n    coordArray: {\r\n      type: Array,\r\n      // eslint-disable-next-line vue/require-valid-default-prop\r\n      default: [],\r\n    },\r\n    points: {\r\n      type: Array,\r\n      // eslint-disable-next-line vue/require-valid-default-prop\r\n      default: [],\r\n    },\r\n    strokeLine: {\r\n      type: String,\r\n      default: '#000000'\r\n    }\r\n  },\r\n  methods: {\r\n    drawBoundary(context, coord) {\r\n      context.beginPath();\r\n      context.strokeStyle = this.strokeLine;\r\n      context.lineWidth = 2;\r\n      context.moveTo(coord[1][0] * this.scaleX, coord[0][0] * this.scaleY);\r\n\r\n      for (let i = 1; i < coord[0].length; i++) {\r\n        context.lineTo(coord[1][i] * this.scaleX, coord[0][i] * this.scaleY);\r\n      }\r\n      context.closePath();\r\n      context.stroke();\r\n    },\r\n    drawDistaceMap(context, points, coord) {\r\n      context.lineWidth = 0.5;\r\n      context.strokeStyle = \"black\";\r\n      for (let i = 0; i < points.length; i++) {\r\n        // draw the boundary points\r\n        for (let j = 0; j < coord[0][0].length; j++) {\r\n          context.beginPath();\r\n          context.moveTo(points[i][1] * this.scaleX, points[i][0] * this.scaleY);\r\n          context.lineTo(coord[i][1][j] * this.scaleX, coord[i][0][j] * this.scaleY);\r\n          context.stroke();\r\n        }\r\n        context.strokeStyle = 'black';\r\n        context.lineWidth = 0.5;\r\n        context.stroke();\r\n      }\r\n    },\r\n    handleShowDistanceMap() {\r\n      const canvas = this.$refs.canvas;\r\n      const context = canvas.getContext(\"2d\");\r\n      if (this.distanceMap == false) {\r\n        this.drawDistaceMap(context, this.points, this.coordArray);\r\n      } else {\r\n        this.drawImageOnCanvas();\r\n      }\r\n    },\r\n    handleAllPoints() {\r\n      const canvas = this.$refs.canvas;\r\n      const context = canvas.getContext(\"2d\");\r\n      if (this.labelAll == false) {\r\n        for (let i = 0; i < this.coordArray.length; i++) {\r\n          this.drawBoundary(context, this.coordArray[i]);\r\n          this.pointClicked[i] = 1;\r\n        }\r\n      } else {\r\n        this.drawImageOnCanvas();\r\n        this.pointClicked = [];\r\n      }\r\n    },\r\n    handleClickPoint(index) {\r\n      if (this.pointClicked[index]) {\r\n        return\r\n      }\r\n      if (this.curPoint != -1) {\r\n        this.prevPoint = this.curPoint;\r\n      }\r\n      this.pointClicked = [];\r\n      this.pointClicked[index] = 1;\r\n      this.curPoint = index;\r\n\r\n      const canvas = this.$refs.canvas;\r\n      const context = canvas.getContext(\"2d\");\r\n      const image = new Image();\r\n      image.src = this.source;\r\n      // Clear the pre boundary\r\n      if (this.prevPoint != -1) {\r\n        context.drawImage(image, 0, 0, this.canvasWidth, this.canvasHeight);\r\n      }\r\n      // Draw new boundary\r\n      this.drawBoundary(context, this.coordArray[this.curPoint]);\r\n    },\r\n    calculateCanvasSize() {\r\n      const image = new Image();\r\n      image.src = this.source;\r\n\r\n      // Calculate the canvas dimensions based on the image's aspect ratio\r\n      image.onload = () => {\r\n        const aspectRatio = image.width / image.height;\r\n\r\n        // Set canvas width within the specified range\r\n        this.canvasWidth = Math.min(Math.max(image.width, this.minWidth), this.maxWidth);\r\n\r\n        // Calculate and set canvas height to maintain the image's aspect ratio\r\n        this.canvasHeight = Math.round(this.canvasWidth / aspectRatio);\r\n\r\n        this.scaleX = this.canvasWidth / image.width;\r\n        this.scaleY = this.canvasHeight / image.height;\r\n      };\r\n    },\r\n    drawImageOnCanvas() {\r\n      return new Promise(() => {\r\n        const canvas = this.$refs.canvas;\r\n        const context = canvas.getContext('2d');\r\n\r\n        const image = new Image();\r\n        image.onload = () => {\r\n          context.drawImage(image, 0, 0, this.canvasWidth, this.canvasHeight);\r\n          // You can add additional drawing logic here if needed\r\n        };\r\n\r\n        image.src = this.source;\r\n      })\r\n    },\r\n    initPanzoom() {\r\n      // Get the panzoom container and target elements using refs\r\n      const container = this.$refs.panzoomElement;\r\n      const target = this.$refs.canvas;\r\n\r\n      // Initialize Panzoom\r\n      const pz = panzoom(target, {\r\n        // You can customize options here\r\n        maxZoom: 10,\r\n        minZoom: 1,\r\n      });\r\n\r\n      // Optional: Add event listeners for additional functionality\r\n      container.addEventListener('wheel', pz.zoomWithWheel);\r\n    },\r\n  },\r\n};\r\n</script>\r\n\r\n<style scoped>\r\n.result {\r\n  display: flex;\r\n  column-gap: 100px;\r\n  align-items: center;\r\n}\r\n\r\n@media only screen and (max-width: 900px) {\r\n  .result {\r\n    flex-direction: column;\r\n  }\r\n}\r\n\r\n.image-box {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n  row-gap: 20px;\r\n  margin-bottom: 100px;\r\n}\r\n\r\n.image {\r\n  border: 1px solid lightgreen;\r\n  border-radius: 4px;\r\n  overflow: hidden;\r\n}\r\n\r\n.image img {\r\n  min-width: 400px;\r\n  min-height: 400px;\r\n  max-width: 500px;\r\n  max-height: 500px;\r\n  transition: transform 0.3s ease;\r\n}\r\n\r\n.roi-manager {\r\n  color: #fff;\r\n  display: flex;\r\n  flex-direction: column;\r\n  border-radius: 3px;\r\n  border: 1px solid lightgreen;\r\n  width: 150px;\r\n  /* margin-top: -100px; */\r\n  margin-bottom: 100px;\r\n}\r\n\r\n.roi-points {\r\n  color: #fff;\r\n  max-height: 300px;\r\n  min-height: 200px;\r\n  display: flex;\r\n  flex-direction: column;\r\n  overflow: scroll;\r\n}\r\n\r\n.roi-extension {\r\n  height: 80px;\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  font-size: 20px;\r\n}\r\n\r\n.point {\r\n  display: flex;\r\n  height: 50px;\r\n  font-size: 20px;\r\n  justify-content: center;\r\n  border-bottom: 1px solid lightgreen;\r\n  cursor: pointer;\r\n}\r\n\r\n.bg-green {\r\n  background-color: lightgreen;\r\n  color: #000;\r\n}\r\n</style>\r\n  \r\n\r\n"],"mappings":"AAwCA,OAAOA,OAAM,MAAO,SAAS;AAE7B,eAAe;EACbC,IAAI,EAAE,UAAU;EAChBC,IAAIA,CAAA,EAAG;IACL,OAAO;MACLC,KAAK,EAAE,CAAC;MAAE;MACVC,WAAW,EAAE,GAAG;MAAE;MAClBC,YAAY,EAAE,GAAG;MAAE;MACnBC,QAAQ,EAAE,GAAG;MACbC,QAAQ,EAAE,GAAG;MACbC,YAAY,EAAE,EAAE;MAChBC,SAAS,EAAE,CAAC,CAAC;MACbC,QAAQ,EAAE,CAAC,CAAC;MACZC,MAAM,EAAE,CAAC;MACTC,MAAM,EAAE,CAAC;MACTC,QAAQ,EAAE,KAAK;MACfC,WAAW,EAAE;IACf,CAAC;EACH,CAAC;EACDC,KAAK,EAAE;IACLC,MAAMA,CAAA,EAAG;MACP,IAAI,CAACC,iBAAiB,CAAC,CAAC;IAC1B;EACF,CAAC;EACDC,OAAOA,CAAA,EAAG;IACR;IACA,IAAI,CAACC,WAAW,CAAC,CAAC;;IAElB;IACA,IAAI,CAACC,mBAAmB,CAAC,CAAC;IAC1B,IAAI,CAACH,iBAAiB,CAAC,CAAC;EAC1B,CAAC;EACDI,KAAK,EAAE;IACLC,KAAK,EAAE;MACLC,IAAI,EAAEC,MAAM;MACZC,OAAO,EAAE;IACX,CAAC;IACDC,GAAG,EAAE;MACHH,IAAI,EAAEC,MAAM;MACZC,OAAO,EAAE;IACX,CAAC;IACDT,MAAM,EAAE,CAAC,CAAC;IACVW,UAAU,EAAE;MACVJ,IAAI,EAAEK,KAAK;MACX;MACAH,OAAO,EAAE;IACX,CAAC;IACDI,MAAM,EAAE;MACNN,IAAI,EAAEK,KAAK;MACX;MACAH,OAAO,EAAE;IACX,CAAC;IACDK,UAAU,EAAE;MACVP,IAAI,EAAEC,MAAM;MACZC,OAAO,EAAE;IACX;EACF,CAAC;EACDM,OAAO,EAAE;IACPC,YAAYA,CAACC,OAAO,EAAEC,KAAK,EAAE;MAC3BD,OAAO,CAACE,SAAS,CAAC,CAAC;MACnBF,OAAO,CAACG,WAAU,GAAI,IAAI,CAACN,UAAU;MACrCG,OAAO,CAACI,SAAQ,GAAI,CAAC;MACrBJ,OAAO,CAACK,MAAM,CAACJ,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,CAACvB,MAAM,EAAEuB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,CAACtB,MAAM,CAAC;MAEpE,KAAK,IAAI2B,CAAA,GAAI,CAAC,EAAEA,CAAA,GAAIL,KAAK,CAAC,CAAC,CAAC,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;QACxCN,OAAO,CAACQ,MAAM,CAACP,KAAK,CAAC,CAAC,CAAC,CAACK,CAAC,IAAI,IAAI,CAAC5B,MAAM,EAAEuB,KAAK,CAAC,CAAC,CAAC,CAACK,CAAC,IAAI,IAAI,CAAC3B,MAAM,CAAC;MACtE;MACAqB,OAAO,CAACS,SAAS,CAAC,CAAC;MACnBT,OAAO,CAACU,MAAM,CAAC,CAAC;IAClB,CAAC;IACDC,cAAcA,CAACX,OAAO,EAAEJ,MAAM,EAAEK,KAAK,EAAE;MACrCD,OAAO,CAACI,SAAQ,GAAI,GAAG;MACvBJ,OAAO,CAACG,WAAU,GAAI,OAAO;MAC7B,KAAK,IAAIG,CAAA,GAAI,CAAC,EAAEA,CAAA,GAAIV,MAAM,CAACW,MAAM,EAAED,CAAC,EAAE,EAAE;QACtC;QACA,KAAK,IAAIM,CAAA,GAAI,CAAC,EAAEA,CAAA,GAAIX,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAACM,MAAM,EAAEK,CAAC,EAAE,EAAE;UAC3CZ,OAAO,CAACE,SAAS,CAAC,CAAC;UACnBF,OAAO,CAACK,MAAM,CAACT,MAAM,CAACU,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC5B,MAAM,EAAEkB,MAAM,CAACU,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC3B,MAAM,CAAC;UACtEqB,OAAO,CAACQ,MAAM,CAACP,KAAK,CAACK,CAAC,CAAC,CAAC,CAAC,CAAC,CAACM,CAAC,IAAI,IAAI,CAAClC,MAAM,EAAEuB,KAAK,CAACK,CAAC,CAAC,CAAC,CAAC,CAAC,CAACM,CAAC,IAAI,IAAI,CAACjC,MAAM,CAAC;UAC1EqB,OAAO,CAACU,MAAM,CAAC,CAAC;QAClB;QACAV,OAAO,CAACG,WAAU,GAAI,OAAO;QAC7BH,OAAO,CAACI,SAAQ,GAAI,GAAG;QACvBJ,OAAO,CAACU,MAAM,CAAC,CAAC;MAClB;IACF,CAAC;IACDG,qBAAqBA,CAAA,EAAG;MACtB,MAAMC,MAAK,GAAI,IAAI,CAACC,KAAK,CAACD,MAAM;MAChC,MAAMd,OAAM,GAAIc,MAAM,CAACE,UAAU,CAAC,IAAI,CAAC;MACvC,IAAI,IAAI,CAACnC,WAAU,IAAK,KAAK,EAAE;QAC7B,IAAI,CAAC8B,cAAc,CAACX,OAAO,EAAE,IAAI,CAACJ,MAAM,EAAE,IAAI,CAACF,UAAU,CAAC;MAC5D,OAAO;QACL,IAAI,CAACV,iBAAiB,CAAC,CAAC;MAC1B;IACF,CAAC;IACDiC,eAAeA,CAAA,EAAG;MAChB,MAAMH,MAAK,GAAI,IAAI,CAACC,KAAK,CAACD,MAAM;MAChC,MAAMd,OAAM,GAAIc,MAAM,CAACE,UAAU,CAAC,IAAI,CAAC;MACvC,IAAI,IAAI,CAACpC,QAAO,IAAK,KAAK,EAAE;QAC1B,KAAK,IAAI0B,CAAA,GAAI,CAAC,EAAEA,CAAA,GAAI,IAAI,CAACZ,UAAU,CAACa,MAAM,EAAED,CAAC,EAAE,EAAE;UAC/C,IAAI,CAACP,YAAY,CAACC,OAAO,EAAE,IAAI,CAACN,UAAU,CAACY,CAAC,CAAC,CAAC;UAC9C,IAAI,CAAC/B,YAAY,CAAC+B,CAAC,IAAI,CAAC;QAC1B;MACF,OAAO;QACL,IAAI,CAACtB,iBAAiB,CAAC,CAAC;QACxB,IAAI,CAACT,YAAW,GAAI,EAAE;MACxB;IACF,CAAC;IACD2C,gBAAgBA,CAACC,KAAK,EAAE;MACtB,IAAI,IAAI,CAAC5C,YAAY,CAAC4C,KAAK,CAAC,EAAE;QAC5B;MACF;MACA,IAAI,IAAI,CAAC1C,QAAO,IAAK,CAAC,CAAC,EAAE;QACvB,IAAI,CAACD,SAAQ,GAAI,IAAI,CAACC,QAAQ;MAChC;MACA,IAAI,CAACF,YAAW,GAAI,EAAE;MACtB,IAAI,CAACA,YAAY,CAAC4C,KAAK,IAAI,CAAC;MAC5B,IAAI,CAAC1C,QAAO,GAAI0C,KAAK;MAErB,MAAML,MAAK,GAAI,IAAI,CAACC,KAAK,CAACD,MAAM;MAChC,MAAMd,OAAM,GAAIc,MAAM,CAACE,UAAU,CAAC,IAAI,CAAC;MACvC,MAAMI,KAAI,GAAI,IAAIC,KAAK,CAAC,CAAC;MACzBD,KAAK,CAACE,GAAE,GAAI,IAAI,CAACvC,MAAM;MACvB;MACA,IAAI,IAAI,CAACP,SAAQ,IAAK,CAAC,CAAC,EAAE;QACxBwB,OAAO,CAACuB,SAAS,CAACH,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAACjD,WAAW,EAAE,IAAI,CAACC,YAAY,CAAC;MACrE;MACA;MACA,IAAI,CAAC2B,YAAY,CAACC,OAAO,EAAE,IAAI,CAACN,UAAU,CAAC,IAAI,CAACjB,QAAQ,CAAC,CAAC;IAC5D,CAAC;IACDU,mBAAmBA,CAAA,EAAG;MACpB,MAAMiC,KAAI,GAAI,IAAIC,KAAK,CAAC,CAAC;MACzBD,KAAK,CAACE,GAAE,GAAI,IAAI,CAACvC,MAAM;;MAEvB;MACAqC,KAAK,CAACI,MAAK,GAAI,MAAM;QACnB,MAAMC,WAAU,GAAIL,KAAK,CAACM,KAAI,GAAIN,KAAK,CAACO,MAAM;;QAE9C;QACA,IAAI,CAACxD,WAAU,GAAIyD,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,GAAG,CAACV,KAAK,CAACM,KAAK,EAAE,IAAI,CAACrD,QAAQ,CAAC,EAAE,IAAI,CAACC,QAAQ,CAAC;;QAEhF;QACA,IAAI,CAACF,YAAW,GAAIwD,IAAI,CAACG,KAAK,CAAC,IAAI,CAAC5D,WAAU,GAAIsD,WAAW,CAAC;QAE9D,IAAI,CAAC/C,MAAK,GAAI,IAAI,CAACP,WAAU,GAAIiD,KAAK,CAACM,KAAK;QAC5C,IAAI,CAAC/C,MAAK,GAAI,IAAI,CAACP,YAAW,GAAIgD,KAAK,CAACO,MAAM;MAChD,CAAC;IACH,CAAC;IACD3C,iBAAiBA,CAAA,EAAG;MAClB,OAAO,IAAIgD,OAAO,CAAC,MAAM;QACvB,MAAMlB,MAAK,GAAI,IAAI,CAACC,KAAK,CAACD,MAAM;QAChC,MAAMd,OAAM,GAAIc,MAAM,CAACE,UAAU,CAAC,IAAI,CAAC;QAEvC,MAAMI,KAAI,GAAI,IAAIC,KAAK,CAAC,CAAC;QACzBD,KAAK,CAACI,MAAK,GAAI,MAAM;UACnBxB,OAAO,CAACuB,SAAS,CAACH,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,CAACjD,WAAW,EAAE,IAAI,CAACC,YAAY,CAAC;UACnE;QACF,CAAC;QAEDgD,KAAK,CAACE,GAAE,GAAI,IAAI,CAACvC,MAAM;MACzB,CAAC;IACH,CAAC;IACDG,WAAWA,CAAA,EAAG;MACZ;MACA,MAAM+C,SAAQ,GAAI,IAAI,CAAClB,KAAK,CAACmB,cAAc;MAC3C,MAAMC,MAAK,GAAI,IAAI,CAACpB,KAAK,CAACD,MAAM;;MAEhC;MACA,MAAMsB,EAAC,GAAIrE,OAAO,CAACoE,MAAM,EAAE;QACzB;QACAE,OAAO,EAAE,EAAE;QACXC,OAAO,EAAE;MACX,CAAC,CAAC;;MAEF;MACAL,SAAS,CAACM,gBAAgB,CAAC,OAAO,EAAEH,EAAE,CAACI,aAAa,CAAC;IACvD;EACF;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}